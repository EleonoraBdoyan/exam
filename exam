from abc import ABC, abstractmethod


class Property(ABC):
    def __init__(self, address, price, features):
        self.address = address
        self.price = price
        self.features = features

    @abstractmethod
    def discount(self):
        pass


class ResidentialProperty(Property):
    def discount(self):
        self.price = self.price * 0.9


class CommercialProperty(Property):
    def discount(self):
        self.price = self.price * 0.7


class Agent:
    def __init__(self, name, contactInfo, balance):
        self.name = name
        self.contactInfo = contactInfo
        self.balance = balance
        self.propertiesAvailable = []
        self.clients = []

    def addClient(self, info):
        self.clients.append(info)


    def profit(self, property):
        profit = property.price * 0.1
        self.balance += profit


class Client:
    def __init__(self, name, contactInfo, balance):
        self.name = name
        self.contactInfo = contactInfo
        self.balance = balance
        self.currentlyAvailable = []
        self.properties = []
        self.__agent = None

    def getMoney(self, property):
        self.balance -= property.price

    def getAgent(self):
        return self.__agent

    def setAgent(self, agent):
        self.__agent = agent


from abc import ABC, abstractmethod
import random
import agent, client, property


class RealEstateSystem(ABC):
    def __init__(self):
        pass

    @abstractmethod
    def addProperty(self):
        raise NotImplementedError

    @abstractmethod
    def searchProperty(self, client, address):
        raise NotImplementedError

    @abstractmethod
    def purchaseProperty(self, property, client, agent):
        raise NotImplementedError

    @abstractmethod
    def getAgent(self, client):
        raise NotImplementedError


class MySystem(RealEstateSystem):
    def __init__(self):
        self.properties = []
        self.agents = []
        self.clients = []

    def addProperty(self, property):
        self.properties.append(property)
        for agent in self.agents:
            agent.propertiesAvailable.append(property)

    def searchProperty(self, client, address):
        for property in self.properties:
            if property.address == address:
                client.currentlyAvailable.append(property)

    def purchaseProperty(self, property, client, agent):
        if client.balance >= property.price:
            client.properties.append(property)
            client.getMoney(property)
            client.getAgent().profit(property)
        else:
            print('Not enough money')

    def getAgent(self, client):
        agent = random.randint(0, len(self.agents))
        client.setAgent(self.agents[agent])

        info = {'name': client.name, 'contact': client.contactInfo}
        agent.addClient(info)


# Write a program that simulates a social media platform. The program should have classes for users, posts, and comments.
# Users should have attributes such as name and contact information.
# Posts should have attributes such as the user making the post, the post content, and the date/time of the post.
# Comments should have attributes such as the user making the comment, the comment content, and the date/time of the comment.
# The program should allow users to create and share posts, comment on posts, and interact with other users.
# Use inheritance to implement classes for different types of posts (e.g., text, photo) and abstract classes for social media operations.

from abc import ABC, abstractmethod


class User:
    def __init__(self, name, contact):
        self.name = name
        self.contact = contact
        self.__posts = []
        self.__messages = {}

    def addPost(self, post):
        self.__posts.append(post)

    def receiveMessage(self, userName, message):
        if userName in self.__messages:
            self.__messages[userName].append(message)
        else:
            self.__messages.update({userName: [message]})


class Post(ABC):
    def __init__(self, user, content, date):
        self.user = user
        self.content = content
        self.date = date
        self.__comments = []

    @abstractmethod
    def viewPost(self):
        raise NotImplementedError

    def viewComment(self):
        for comment in self.__comments:
            print(comment)

    def addComment(self, comment):
        self.__comments.append(comment)


class Text(Post):
    def viewPost(self):
        return f'{self.user.name} ({self.date}):\n "{self.content}"'


class Photo(Post):
    def viewPost(self):
        return f'{self.user.name} ({self.date}):\n **{self.content}**'


class Comment:
    def __init__(self, user, content, date):
        self.user = user
        self.content = content
        self.date = date

    def __str__(self):
        return f'{self.user.name} ({self.date}):\n {self.content}'


class SocialMediaPlatform(ABC):
    def __init__(self):
        self.__users = []

    @abstractmethod
    def register(self, userName, userContact):
        raise NotImplementedError

    @abstractmethod
    def createPost(self, type, user, content, date):
        raise NotImplementedError

    @abstractmethod
    def sharePost(self, userName, post):
        raise NotImplementedError

    @abstractmethod
    def commentPost(self, user, post, comment):
        raise NotImplementedError

    @abstractmethod
    def sendMessage(self, sender, receiver, message):
        receiver.receiveMessage(sender, message)


class Facebook(SocialMediaPlatform):
    def register(self, userName, userContact):
        user = User(userName, userContact)
        self.__users.append(user)

    def createPost(self, type, user, content, date):
        if type == 'Text':
            post = Text(user, content, date)
        elif type == 'Photo':
            post = Photo(user, content, date)
        user.addPost(post)

    def sharePost(self, userName, post):
        for user in self.__users:
            if user.name == userName:
                user.addPost(post)
                break

    def commentPost(self, post, user, comment, date):
        comment = Comment(user, comment, date)
        post.addComment(comment)

    def sendMessage(self, sender, receiver, message):
        receiver.receiveMessage(sender, message)


# Write a program that simulates a movie rental system.
# The program should allow customers to search for and rent movies,
# view their rental history, and return movies. Use interfaces to implement classes for different
# types of movies (e.g., comedy, drama) and abstract classes for rental operations.
import abc


class Movie(abc.ABC):
    def __init__(self, title: str, price: int):
        self.title = title
        self.price = price
        self.genre = self.__class__.__name__
        self.rating = 0

    @abc.abstractmethod
    def discount(self):
        raise NotImplementedError


class Comedy(Movie):
    def discount(self):
        self.price = self.price * 0.9


class Drama(Movie):
    def discount(self):
        self.price = self.price * 0.9


class Customer:
    def __init__(self, name, contact_information, money):
        self.name = name
        self.contact_information = contact_information
        self.money = money
        self.movie_availibility = []
        self.rented_movies = []
        self.rental_history = []

    def view_rental_history(self):
        for i in self.rental_history:
            print(f"{i.movie.title}, {i.duration}")


class Rental:
    def __init__(self, customer, movie, duration):
        self.customer = customer
        self.movie = movie
        self.duration = duration

    # def get_movie_title(self):
    #     print(self.movie.title)
    #     return self.movie.title

class RentalSystem(abc.ABC):
    @abc.abstractmethod
    def search_movie(self, customer, movie_title):
        raise NotImplementedError

    @abc.abstractmethod
    def rent_movie(self, movie, customer, duration):
        raise NotImplementedError


class MySystem(RentalSystem):
    def __init__(self):
        self.movies = []
        self.customers = []
        self.rentals = []

    def add_movie(self, movie):
        self.movies.append(movie)

    def add_customer(self, customer):
        self.customers.append(customer)

    def search_movie(self, customer, movie_title):
        for i in self.movies:
            if i.title == movie_title:
                customer.movie_availibility.append(i)

    def rent_movie(self, movie, customer, duration):
        movie.discount()
        if customer.money >= movie.price:
            customer.rented_movies.append(movie)
            self.movies.remove(movie)
            customer.money -= movie.price
            rental = Rental(customer, movie, duration)
            self.rentals.append(rental)
            customer.rental_history.append(rental)


m = Comedy("KINO", 100)
c = Customer("Elonora", "093420841", 200)
system = MySystem()
system.add_movie(m)
print(system.movies)
system.add_customer(c)
print(system.customers)


system.search_movie(c, "KINO")
print(c.movie_availibility)
system.rent_movie(m, c, 20)
c.view_rental_history()


class Movie:
    def __init__(self, title: str, duration: float, rating: float):
        self.title = title
        self.duration = duration
        self.rating = rating

movie  = Movie("Kino", 1.5, 5)

class Client:
    def __init__(self, name: str, contact_information: str):
        self.name = name
        self.contact_information = contact_information
        self.ticket = None
        self.available_movie = []

client  = Client("Eleonora", "093420841")

class Ticket:
    def __init__(self, movie_time, showtime, seat_number):
        self.movie_time = movie_time
        self.showtime = showtime
        self.seat_number = seat_number


class Admin:
    def __init__(self, name):
        self.name = name
        self.movies = []



    def add_movies(self, movie):
        self.movies.append(movie)

    def remove_movies(self, movie):
        self.movies.remove(movie)

admin = Admin("HHHH")

class BookingSystem:
    def __init__(self):
        self.clients = []
        self.showtimes = {}
        self.movies = []
        self.seats = [1, 2, 3, 4, 5]

    def add_client(self, name, contact_information):
        client = Client(name, contact_information)
        self.clients.append(client)

    def search_movies(self, movie_title, client):
        for i in self.movies:
            if i.title.lower() == movie_title.lower():
                client.available_movie.append(movie)

    def add_movies(self, movie, admin):
        admin.add_movies(movie)
        self.movies.append(movie)

    def remove_movies(self, movie, admin):
        admin.remove_movies(movie)
        self.movies.remove(movie)

    def add_show_time(self, movie, time):
        self.showtimes[movie.title] = [self.seats, time]

    def buy_ticket(self, movie, client, time):
        import random
        if movie in self.movies and not len(self.showtimes[movie][0]) <= 0 and time == self.showtimes[movie][1]:
            seat = random.choice(self.showtimes[movie][0])
            self.showtimes[movie][0].remove(seat)
            ticket = Ticket(movie, seat, time)
            client.ticket = ticket
        else:
            print("no movie")


    def report(self):
        path = input("Enter file name") + "txt"
        with open(path, "w") as f:
            for i, j in self.showtimes.items():
                f.write(f"{i}, {j[0]}, {j[1]}" )



booking = BookingSystem()
booking.add_movies(movie, admin)
print(booking.movies)
booking.add_show_time(movie, "3:00" )
print(booking.showtimes)
booking.buy_ticket(movie, client, "3:00")
print(client.ticket)
booking.report()




# Write a program that simulates a banking system. The program should have classes
# for customers, accounts, and transactions. Customers should have attributes such as name,
# address, and contact information. Accounts should have attributes such as account type, balance,
# and interest rate. Transactions should have attributes such as the account involved, the transaction type,
# and the amount of the transaction. Use inheritance to implement classes for different types of accounts
# (e.g., savings, checking) and abstract classes for account operations.
import abc
from datetime import datetime


class Customer:
    def __init__(self, name, address, contact_info):
        self.name = name
        self.address = address
        self.contact_info = contact_info
        self.account = []


class Account:

    def __init__(self, account_number):
        self.type = self.__class__.__name__
        self.balance = 0
        self.rate = 0
        self.account_number = account_number

    def add_money(self, account_number, amount):
        self.balance += amount

    def withdraw_money(self, account_number, amount):
        self.balance -= amount


class Savings(Account):
    def __init__(self, account_number):
        super().__init__(account_number)
        self.rate = 0.1

    def add_rate_to_balance(self):
        if datetime.now().day == 9:
            self.balance += self.balance * self.rate
            print(self.balance)


class Transaction:
    def __init__(self, amount, transaction_type):
        self.account = account
        self.transaction_type = transaction_type
        self.amount = amount

    def transactin(self, account_number, amount, type):
        if type == "add":
            account.add_money(account_number, amount)
        elif type == "withdraw":
            account.withdraw_money(account_number, amount)
        else:
            print("Incorrect transaction type.")


class Bank(abc.ABC):
    @abc.abstractmethod
    def add_clients(self, customer):
        pass

    @abc.abstractmethod
    def add_accounts(self, customer,  type, account_number):
        pass

    @abc.abstractmethod
    def add_money(self, account_number, amount):
        pass

    @abc.abstractmethod
    def withdraw_money(self, customer, account_number, amount):
        pass

class MyBank(Bank):
    def __init__(self):
        self.customers = []
        self.accounts = []
        self.baza = {}


    def add_clients(self, customer):
        self.customers.append(customer)

    def add_accounts(self, customer, type, account_number):
        if not account_number in [i.account_number for i in self.accounts]:
            if type == "savings":
                account = Savings(account_number)
                customer.account.append(account)
                self.accounts.append(account)
                self.baza[account] = customer

    def add_money(self, account_number, amount):

        for i in self.accounts:
            if i.account_number == account_number:
                i.balance += amount

    def withdraw_money(self, customer, account_number, amount):
        for i in customer.account:
            if i.account_number == account_number:
                if i.balance >= amount:
                    i.balance -= amount
                else:
                    print("Insufficient funds.")
                    break
            else:
                print("It's not your account.")

    def report(self):
        path = input("Enter filename: ")
        with open(path + ".txt", "w") as f:
            for i, j in self.baza.items():
                f.write(f"{i.account_number}, {i.balance}, {j.name}\n")

customer = Customer("Eleonora","yerevan", "093420841")
bank = MyBank()
bank.add_clients(customer)
bank.add_accounts(customer, "savings", 123456)
bank.add_accounts(customer, "savings", 123458)
bank.add_money(123456, 200)
for i in bank.accounts:
    i.add_rate_to_balance()

bank.report()

# Write a program that simulates a hospital management system.
# The program should have classes for patients, doctors, and medical staff.
# Patients should have attributes such as name, age, and medical history.
# Doctors should have attributes such as name and contact information.
# Medical staff should have attributes such as name and position. The
# program should allow doctors to manage patient information and appointments,
# and medical staff to manage hospital operations. Use inheritance to implement
# classes for different types of medical procedures (e.g., surgeries, check-ups) and abstract
# classes for medical operations.
import abc
import datetime

class Patient:
    def __init__(self):
        print("dear  patient enter your details")
        self.name = input("Enter name: ")
        self.check_name(self.name)
        self.gender = input("Enter gender: ")
        self.date_of_birth = input("Enter date_of_birth: ")
        self.contact_info = input("Enter your tel number: ")
        self.condition = input("Enter medical condition: ")
        self.medical_history = None

    @staticmethod
    def check_name(name):
        if not name.isalpha():
            raise TypeError


class Doctors:
    def __init__(self):
        print("Dear doctor enter your details: ")
        self.name = input("Enter your nmae.")
        self.specialization = input("Enter your specialization.")
        self.experince_years = input("Enter your experience_years.")
        self.contact_info = input("Enter your tel number:")

class MedHistory:
    def __init__(self, patient):
        self.patient = patient
        self.diagnoses = []
        self.treatments = []
        self.medications = []


class HealthCareSystem:
    def __init__(self):
        self.patients = []
        self.doctors = []

    def register_doctors(self):
        doctor = Doctors()
        self.doctors.append(doctor)

    def register_patient(self):
        patient = Patient()
        self.patients.append(patient)

    def med_history_record(self, patient_name):
        patient = None
        for i in self.patients:
            if i.name.lower() == patient_name.lower():
                patient = i
        if patient_name.lower() not in [i.name.lower() for i in self.patients]:
            print("You should register at first.")
            return
        medical_history = MedHistory(patient)
        patient.medical_history = medical_history
        record_type = input("Enter what do you want to record,1 for diagnoses,2 for treatments and 3 for medications.")
        if "1" in record_type:
            diagnoses = input("Enter diagnoses: ")
            medical_history.diagnoses.append(diagnoses)
        if "2" in record_type:
            treatments = input("Enter treatments: ")
            medical_history.treatments.append(treatments)
        if "3" in record_type:
            medications = input("Enter medications")
            medical_history.medications.append(medications)
        with open(f"{patient.name}.txt", "a") as f:
            f.write(f'''personal details: name is {patient.name}, "
                    date of birth is {patient.date_of_birth}, gender is {patient.gender}, contact information, current condition is {patient.condition}.\n 
                    medical_history: diagnoses are {patient.medical_history.diagnoses}, treatments are {patient.medical_history.treatments}, medications are {patient.medical_history.medications}''')


    def med_history_generation(self, patient_name):
        for i in self.patients:
            if i.name == patient_name:
                print(f"personal details: name is {i.name}, date of birth is {i.date_of_birth}, gender is {i.gender}, contact information is {i.medical_history}, current condition is {i.condition}.")
                print(f"medical_history: diagnoses are {i.medical_history.diagnoes}, treatments are {i.medical_history.treatments}, medications are {i.medical_history.medications}")
            else:
                print("There is no such a patient.")


def client():
    system = HealthCareSystem()
    while True:
        action = input("Enter 1 to add doctor, 2, to add patient, 3 to record medical history and save into file, 4 to see medical history of a patient.")
        if "1" in action:
            system.register_doctors()
        if "2" in action:
            system.register_patient()
        if "3" in action:
            patient_name  = input("Enter patinet name: ")
            system.med_history_record(patient_name)
        if "4" in action:
            patient_name  = input("Enter patinet name: ")
            system.med_history_generation(patient_name)
        if "0" in action:
            break


client()

import datetime


class Customer:
    def __init__(self):
        self.name = input("Enter your name: ")
        self.contact = input("Enter your tel. number: ")
        self.meter_number = None
        self.consumption = 0
        self.bill = []
        self.meter = None


class Meter:
    def __init__(self):
        self.rate = input("Enter unit price: ")
        self.consumption = 0
        self.number = input("Enter meter number: ")
        self.customer = None


class Bill:
    def __init__(self, consumption, customer, total):
        self.consumption = consumption
        self.customer = customer
        self.total = total


class System:
    def __init__(self):
        self.customers = []
        self.bills = []


    def register_customer(self):
        meter = Meter()
        customer = Customer()
        customer.meter_number = meter.number
        meter.customer = customer
        customer.meter = meter
        self.customers.append(customer)


    def bill_generation(self, meter_number):
        current_date = datetime.datetime.now().strftime("%Y-%m-%d")
        if meter_number not in [i.meter_number for i in self.customers]:
            print("You must register at first.")
        else:
            customer = None
            for i in self.customers:
                if i.meter_number == meter_number:
                    customer = i
                customer.consumption += int(input("Enter electricity consuption units: "))
                customer.meter.consumption = customer.consumption
                due_amount = customer.consumption * int(customer.meter.rate)
                bill = Bill(customer.consumption, customer, due_amount)
                customer.bill.append(bill)
                self.bills.append(bill)
                print(f"for {customer.name} was generated a bill with the following details: consumption is {customer.consumption} units and due_amount is {due_amount} AMD.")
                with open(f"{customer.name}_{current_date}.txt", "w") as f:
                    f.write(f"{customer.name} - customer.consumption is {customer.consumption}, total due amount is {bill.total}")


system = System()
system.register_customer()
meter_number = input("Enter meter number for bill generation: ")
system.bill_generation(meter_number)


from datetime import datetime


class Customer:
    def __init__(self):
        self.name = input("Enter your name: ")
        self.info = input("Enter your tel. number: ")
        self.interaction_history = []


class Interaction:
    def __init__(self, customer):
        self.customer = customer


class Sale(Interaction):
    def __init__(self, customer):
        super().__init__(customer)
        self.date = None
        self.amount = input("Enter sale amount: ")
        self.warranty = None
        self.compliant = None
        self.product = input("Enter the product you want to bay: ")


class Warranty(Interaction):
    def __init__(self, customer, sale):
        super().__init__(customer)
        self.sale = sale
        self.warranty_cost = input("Enter warranty cost:")
        self.warranty_period = input("Enter warranty period: ")


class Compliant(Interaction):
    def __init__(self, customer, sale):
        super().__init__(customer)
        self.sale = sale
        self.description = input("Enter your compliant: ")


class CRMSystem:
    def __init__(self):
        self.customers = []
        self.sails = []
        self.compliants = []
        self.warranties = []

    def register_customer(self):
        customer = Customer()
        if customer.name.lower() in [i.name.lower() for i in self.customers]:
            print(f"There is already a customer with name {customer.name}. Try again. ")
        else:
            self.customers.append(customer)

    def do_interaction(self):
        customer_name = input("Enter your name: ")
        if customer_name.lower() not in [i.name.lower() for i in self.customers]:
            print("At first you must register.")
        else:
            for i in self.customers:
                if i.name.lower() == customer_name.lower():
                    customer = i
                    inter_type = input("Enter 1 for sale, 2 for complaint: ")
                    if inter_type.strip() == "1":
                        sale = Sale(customer)
                        sale.date = datetime.now()
                        self.sails.append(sale)
                        warranty = Warranty(customer, sale)
                        sale.warranty = warranty
                        customer.interaction_history.append(sale)
                        customer.interaction_history.append(warranty)
                        self.warranties.append(warranty)
                    elif inter_type.strip() == "2":
                        if len(customer.interaction_history) > 0:
                            product_type = input("Enter sold product type you have compliant about: ")
                            for i in customer.interaction_history:
                                if i.product == product_type:
                                    sale = i
                                    compliant = Compliant(customer, sale)
                                    customer.interaction_history.append(compliant)
                                    sale.compliant = compliant
                                    self.compliants.append(compliant)
                                    break
                                else:
                                    print("You haven't bought such a product.")
                        else:
                            print("You haven't  bought anything.")
                    else:
                        print("You must enter 1 or 2.")

    def report_generation(self):
        customer_name = input("Customer name you want to generate report: ")
        if customer_name.lower() not in [i.name.lower() for i in self.customers]:
            print("At first you must register.")
        else:
            for i in self.customers:
                if i.name.lower() == customer_name.lower():
                    customer = i
                    warranty = 0
                    sale = 0
                    compliant = 0
                    for j in customer.interaction_history:
                        if type(j) == Warranty:
                            warranty += 1
                        if type(j) == Sale:
                            sale += 1
                        if type(j) == Compliant:
                            compliant += 1
                    date_time = datetime.now().strftime("%Y-%m-%d")
                    customer_info = f"Customer name is {customer.name}, customer tel number is {customer.info}"
                    print(customer_info + f"\nInteraction info is the following: warranty-{warranty}, sale-{sale}, compliant-{compliant}")
                    with open(f"{customer_name}_{date_time}.txt", "w") as f:
                        f.write(customer_info + f"\nInteraction info is the following: warranty-{warranty}, sale-{sale}, compliant-{compliant}")


def client():
    system = CRMSystem()
    while True:
        action = input("Enter 1 for registration, 2 for interaction, 3 for report: ")
        if "1" in action:
            system.register_customer()
        if "2" in action:
            system.do_interaction()
        if "3" in action:
            system.report_generation()
        if "0" in action:
            break

client()

import abc



class Restaurant():
    def __init__(self):
        self.name = input("Enter restaurant name: ")
        self.menu = Menu()
        self.location = input("Enter location: ")

    def add_dish_to_menu(self):
        while True:
            dish = Dish()
            if dish.name.lower() in [dish.name.lower() for dish in self.menu.dishes]:
                print(f"There is already dish with name {dish.name}")
                del dish
                continue
            else:
                self.menu.dishes.append(dish)
                break

    def remove_dish_from_menu(self):
        while True:
            dish_name = input("Enter dish name you want to remove from menu: ")
            if dish_name.lower() not in [dish.name.lower() for dish in self.menu.dishes]:
                continue
            else:
                break
        for dish in self.menu.dishes:
            if dish.name.lower() == dish.name.lower():
                self.menu.dishes.remove(dish)


class Customer:
    def __init__(self):
        self.name = input("Enter your name: ")
        self.contact_info = input("Enter your tel. number: ")
        self.payment_method = input("Enter payment method ")
        self.bill = None


class Bill:
    def __init__(self):
        self.dishes = []
        self.due_amount = 0
        self.date = None


class Order:
    def __init__(self):
        self.id = input("Create order id for tracking your order: ")
        self.estimated_time = None
        self.status = None
        self.start_time = None
        self.dish_max_time = None


class Dish:
    def __init__(self):
        self.name = input("Enter dish name: ")
        self.price = input("Enter dish price: ")
        self.preparation_period = input("Enter preparation period in minutes: ")


class Menu:
    def __init__(self):
        self.dishes = []

    def menu_description(self):
        for dish in self.dishes:
            print(f"{dish.name} - {dish.price}AMD\n")


class OrderSystem:
    def __init__(self):
        self.restaurants = []
        self.customers = []
        self.orders = []

    def add_restaurant(self):
        while True:
            restaurant = Restaurant()
            if restaurant.name.lower() in [restaurant.name.lower() for restaurant in self.restaurants]:
                print(f"There is already customer with name {restaurant.name}")
                del restaurant
                continue
            else:
                self.restaurants.append(restaurant)
                return restaurant

    def add_customer(self):
        while True:
            customer = Customer()
            if customer.name.lower() in [customer.name.lower() for customer in self.customers]:
                print(f"There is already customer with name {customer.name}")
                del customer
                continue
            else:
                self.customers.append(customer)
                break

    def place_order(self):
        from datetime import datetime
        from time import time
        order_date = datetime.now().strftime("%Y-%m-%d")
        customer_name = input("Enter  your name: ")
        if customer_name.lower() not in [customer.name.lower() for customer in self.customers]:
            print("You must register at first.")
        else:
            customer = None
            for i in self.customers:
                if i.name.lower() == customer_name:
                    customer = i
                    break
        restaurant_name = input("Enter restaurant name: ")
        if restaurant_name.lower() not in [restaurant.name.lower() for restaurant in self.restaurants]:
            print("You must register at first.")
        else:
            restaurant = None
            for j in self.restaurants:
                if j.name.lower() == restaurant_name:
                    restaurant = j
                    break
        print("Menu")
        restaurant.menu.menu_description()
        bill = Bill()
        while True:
            dish_name = input("Enter dish name from the menu or 0 to complete order: ")
            if dish_name == "0":
                break
            elif dish_name.lower() not in [dish.name.lower() for dish in restaurant.menu.dishes]:
                print("Enter dish name from menu.")
            else:
                for i in restaurant.menu.dishes:
                    if i.name == dish_name:
                        bill.dishes.append(i)
                        bill.due_amount += int(i.price)
                        bill.date = order_date
        if len(bill.dishes) > 0:
            customer.bill = bill
        else:
            print("You haven't chosen anything. Try again.")
            return
        order = Order()
        self.orders.append(order)
        order.start_time = time()
        order.dish_max_time = max([int(dish.preparation_period) for dish in bill.dishes]) * 60
        order.estimated_time = f"{(max([int(dish.preparation_period) for dish in bill.dishes]) + 30)//60}hours and {(max([int(dish.preparation_period) for dish in bill.dishes]) + 30)%60} minutes"
        print(f"Bill details")
        for i in bill.dishes:
            print(f"{i.name}-{i.price}AMD\n")
        with open(f"{customer.name}_{order_date}.txt", "w") as f:
            for i in bill.dishes:
                f.write(f"{i.name}-{i.price}AMD\n")

    def order_tracking(self):
        from time import time
        order_id = input("Enter order id: ")
        if order_id not in [order.id for order in self.orders]:
            print("There is no order with that id.")
            return
        for i in self.orders:
            if i.id == order_id:
                if time() - i.start_time < i.dish_max_time:
                    print(time()- i.start_time)
                    print(i.dish_max_time)
                    print("Prepairing")
                if time() - i.start_time >= i.dish_max_time:
                    print("Dispatched")
                if time() - i.start_time - i.dish_max_time - 30*60 >= 0:
                    print("Delivered")



def client():
    system = OrderSystem()
    while True:
        action = input("Enter 1 for restaurant registration, 2 for customer registration, 3 for placing order, 4 for order tracking, 0 to exit: ")
        if "1" in action:
            rest = system.add_restaurant()
            while True:
                add_or_remove = input("Enter 1 to add dishes to the menu, 2 to remove, 0 to exit: ")
                if "1" in add_or_remove:
                    rest.add_dish_to_menu()
                if "2" in add_or_remove:
                    rest.remove_dish_from_menu()
                if "0" in add_or_remove:
                    break
        if "2" in action:
            system.add_customer()
        if "3" in action:
            system.place_order()
        if "4" in action:
            system.order_tracking()
        if "0" in action:
            break

client()

import abc
from datetime import datetime, timedelta


class Book:
    # With the help of this class you can instantiate book objects
    def __init__(self):
        self.title = input("Enter book title: ")
        self.authors = input("Enter authors: ")
        self.genre = input("Enter genre: ")
        self.available = True
        self.borrowed_day = None


class Member:
    def __init__(self):
        self.name = input("Enter your name: ")
        self.info = input("Enter your tel.number: ")
        self.borrowed_book = []


class LibrarySystem(abc.ABC):
    # Abstract class for libraries
    def add_book(self):
        raise NotImplementedError

    def add_member(self):
        raise NotImplementedError

    def search_book(self):
        raise  NotImplementedError


class MYlibrary(LibrarySystem):
    # Concrete class for library instantiation
    def __init__(self):
        self.books = []
        self.members = []

    def add_book(self):
        book = Book()
        if book not in self.books:
            self.books.append(book)
        else:
            print("The book is already registered.")

    def add_member(self):
        member = Member()
        if member not in self.members:
            self.members.append(member)
        else:
            print("The book is already registered.")

    def search_book(self):
        action = input("Enter 1 to search book by title, 2 by author, 3 by genre: ")
        if "1" in action:
            book_title = input("Enter title: ")
            if book_title.lower() not in [b.title.lower() for b in self.books]:
                print("There is no such a book.")
            else:
                books = (b for b in self.books if b.title.lower() == book_title.lower())
                for book in books:
                    if book.available is True:
                        print(f"There is book with {book.title} title and {','.join(book.authors)} authors  and it is available for borrowing.")
                        return book
                    else:
                        print(f"There is book with {book.title} and {book.authors} and it is not available for borrowing.")
        if "2" in action:
            book_author = input("Enter author: ")
            if book_author.lower() not in [book.authors.lower() for book in self.books ]:
                print("There is no such a book.")
            else:
                books = [b for b in self.books if b.authors.lower() == book_author.lower()]
                for book in books:
                    if book.available is True:
                        print(f"There is book with {book.title} and {book.authors} and it is available for borrowing.")
                        return book
                    else:
                        print(f"There is book with {book.title} and {book.authors} and it is not available for borrowing.")
        if "3" in action:
            book_genre = input("Enter book genre: ")
            if book_genre.lower() not in [b.genre.lower() for b in self.books]:
                print("There is no such a book.")
            else:
                books = (b for b in self.books if b.genre.lower() == book_genre.lower())
                for book in books:
                    if book.available is True:
                        print(f"There is book with {book.title} title and {book.authors} authors and it is available for borrowing.")
                        return book
                    else:
                        print(f"There is book with {book.title} and {book.authors} and it is not available for borrowing.")

    def borrow(self):
        member_name = input("Enter your name:")
        if member_name.lower() not in [m.name.lower() for m in self.members]:
            print("Enter you should register at first.")
        else:
            member = next((m for m in self.members if m.name.lower() == member_name.lower()))
            book = self.search_book()
            if book is not None:
                borrowed_days = int(input("Enter number of days you want to borrow the book: "))
                date = datetime.now()
                book.borrowed_day = date
                book.return_date = date + timedelta(days=borrowed_days)
                book.available = False
                member.borrowed_book.append(book)

    def return_book(self):
        member_name = input("Enter your name:")
        if member_name.lower() not in [m.name.lower() for m in self.members]:
            print("Enter you should register at first.")
        else:
            member = next((m for m in self.members if m.name.lower() == member_name.lower()))
            book_title = input("Enter book title, you want to return: ")
            if book_title.lower() not in [b.title.lower() for b in member.borrowed_book]:
                print("You have taken this book from another library")
            else:
                book = next((b for b in member.borrowed_book if b.title == book_title))
                book.available = True
                member.borrowed_book.remove(book)

    def overdue_report(self):
        report_date = datetime.now()
        overdue_books = []
        for member in self.members:
            for book in member.borrowed_book:
                if report_date >= book.return_date + timedelta(days=1):
                    overdue_books.append(f"{member.name} has borrowed {book.title} book, which is overdue for {(report_date - book.return_date).days} days ")
        if len(overdue_books) == 0:
            print("There are no overdue books.")


def client():
    system = MYlibrary()
    while True:
        action = input('''Enter 1 to add book, 2 to add member, 3 to search, 4 to borrow book, 5 to return book, 6 for
overdue report, 0 to exit: ''')
        if "1" in action:
            system.add_book()
        if "2" in action:
            system.add_member()
        if "3" in action:
            system.search_book()
        if "4" in action:
            system.borrow()
        if "5" in action:
            system.return_book()
        if "6" in action:
            system.overdue_report()
        if "0" in action:
            break

client()







































