from abc import ABC, abstractmethod


class Property(ABC):
    def __init__(self, address, price, features):
        self.address = address
        self.price = price
        self.features = features

    @abstractmethod
    def discount(self):
        pass


class ResidentialProperty(Property):
    def discount(self):
        self.price = self.price * 0.9


class CommercialProperty(Property):
    def discount(self):
        self.price = self.price * 0.7


class Agent:
    def __init__(self, name, contactInfo, balance):
        self.name = name
        self.contactInfo = contactInfo
        self.balance = balance
        self.propertiesAvailable = []
        self.clients = []

    def addClient(self, info):
        self.clients.append(info)


    def profit(self, property):
        profit = property.price * 0.1
        self.balance += profit


class Client:
    def __init__(self, name, contactInfo, balance):
        self.name = name
        self.contactInfo = contactInfo
        self.balance = balance
        self.currentlyAvailable = []
        self.properties = []
        self.__agent = None

    def getMoney(self, property):
        self.balance -= property.price

    def getAgent(self):
        return self.__agent

    def setAgent(self, agent):
        self.__agent = agent


from abc import ABC, abstractmethod
import random
import agent, client, property


class RealEstateSystem(ABC):
    def __init__(self):
        pass

    @abstractmethod
    def addProperty(self):
        raise NotImplementedError

    @abstractmethod
    def searchProperty(self, client, address):
        raise NotImplementedError

    @abstractmethod
    def purchaseProperty(self, property, client, agent):
        raise NotImplementedError

    @abstractmethod
    def getAgent(self, client):
        raise NotImplementedError


class MySystem(RealEstateSystem):
    def __init__(self):
        self.properties = []
        self.agents = []
        self.clients = []

    def addProperty(self, property):
        self.properties.append(property)
        for agent in self.agents:
            agent.propertiesAvailable.append(property)

    def searchProperty(self, client, address):
        for property in self.properties:
            if property.address == address:
                client.currentlyAvailable.append(property)

    def purchaseProperty(self, property, client, agent):
        if client.balance >= property.price:
            client.properties.append(property)
            client.getMoney(property)
            client.getAgent().profit(property)
        else:
            print('Not enough money')

    def getAgent(self, client):
        agent = random.randint(0, len(self.agents))
        client.setAgent(self.agents[agent])

        info = {'name': client.name, 'contact': client.contactInfo}
        agent.addClient(info)


# Write a program that simulates a social media platform. The program should have classes for users, posts, and comments.
# Users should have attributes such as name and contact information.
# Posts should have attributes such as the user making the post, the post content, and the date/time of the post.
# Comments should have attributes such as the user making the comment, the comment content, and the date/time of the comment.
# The program should allow users to create and share posts, comment on posts, and interact with other users.
# Use inheritance to implement classes for different types of posts (e.g., text, photo) and abstract classes for social media operations.

from abc import ABC, abstractmethod


class User:
    def __init__(self, name, contact):
        self.name = name
        self.contact = contact
        self.__posts = []
        self.__messages = {}

    def addPost(self, post):
        self.__posts.append(post)

    def receiveMessage(self, userName, message):
        if userName in self.__messages:
            self.__messages[userName].append(message)
        else:
            self.__messages.update({userName: [message]})


class Post(ABC):
    def __init__(self, user, content, date):
        self.user = user
        self.content = content
        self.date = date
        self.__comments = []

    @abstractmethod
    def viewPost(self):
        raise NotImplementedError

    def viewComment(self):
        for comment in self.__comments:
            print(comment)

    def addComment(self, comment):
        self.__comments.append(comment)


class Text(Post):
    def viewPost(self):
        return f'{self.user.name} ({self.date}):\n "{self.content}"'


class Photo(Post):
    def viewPost(self):
        return f'{self.user.name} ({self.date}):\n **{self.content}**'


class Comment:
    def __init__(self, user, content, date):
        self.user = user
        self.content = content
        self.date = date

    def __str__(self):
        return f'{self.user.name} ({self.date}):\n {self.content}'


class SocialMediaPlatform(ABC):
    def __init__(self):
        self.__users = []

    @abstractmethod
    def register(self, userName, userContact):
        raise NotImplementedError

    @abstractmethod
    def createPost(self, type, user, content, date):
        raise NotImplementedError

    @abstractmethod
    def sharePost(self, userName, post):
        raise NotImplementedError

    @abstractmethod
    def commentPost(self, user, post, comment):
        raise NotImplementedError

    @abstractmethod
    def sendMessage(self, sender, receiver, message):
        receiver.receiveMessage(sender, message)


class Facebook(SocialMediaPlatform):
    def register(self, userName, userContact):
        user = User(userName, userContact)
        self.__users.append(user)

    def createPost(self, type, user, content, date):
        if type == 'Text':
            post = Text(user, content, date)
        elif type == 'Photo':
            post = Photo(user, content, date)
        user.addPost(post)

    def sharePost(self, userName, post):
        for user in self.__users:
            if user.name == userName:
                user.addPost(post)
                break

    def commentPost(self, post, user, comment, date):
        comment = Comment(user, comment, date)
        post.addComment(comment)

    def sendMessage(self, sender, receiver, message):
        receiver.receiveMessage(sender, message)


# Write a program that simulates a movie rental system.
# The program should allow customers to search for and rent movies,
# view their rental history, and return movies. Use interfaces to implement classes for different
# types of movies (e.g., comedy, drama) and abstract classes for rental operations.
import abc


class Movie(abc.ABC):
    def __init__(self, title: str, price: int):
        self.title = title
        self.price = price
        self.genre = self.__class__.__name__
        self.rating = 0

    @abc.abstractmethod
    def discount(self):
        raise NotImplementedError


class Comedy(Movie):
    def discount(self):
        self.price = self.price * 0.9


class Drama(Movie):
    def discount(self):
        self.price = self.price * 0.9


class Customer:
    def __init__(self, name, contact_information, money):
        self.name = name
        self.contact_information = contact_information
        self.money = money
        self.movie_availibility = []
        self.rented_movies = []
        self.rental_history = []

    def view_rental_history(self):
        for i in self.rental_history:
            print(f"{i.movie.title}, {i.duration}")


class Rental:
    def __init__(self, customer, movie, duration):
        self.customer = customer
        self.movie = movie
        self.duration = duration

    # def get_movie_title(self):
    #     print(self.movie.title)
    #     return self.movie.title

class RentalSystem(abc.ABC):
    @abc.abstractmethod
    def search_movie(self, customer, movie_title):
        raise NotImplementedError

    @abc.abstractmethod
    def rent_movie(self, movie, customer, duration):
        raise NotImplementedError


class MySystem(RentalSystem):
    def __init__(self):
        self.movies = []
        self.customers = []
        self.rentals = []

    def add_movie(self, movie):
        self.movies.append(movie)

    def add_customer(self, customer):
        self.customers.append(customer)

    def search_movie(self, customer, movie_title):
        for i in self.movies:
            if i.title == movie_title:
                customer.movie_availibility.append(i)

    def rent_movie(self, movie, customer, duration):
        movie.discount()
        if customer.money >= movie.price:
            customer.rented_movies.append(movie)
            self.movies.remove(movie)
            customer.money -= movie.price
            rental = Rental(customer, movie, duration)
            self.rentals.append(rental)
            customer.rental_history.append(rental)


m = Comedy("KINO", 100)
c = Customer("Elonora", "093420841", 200)
system = MySystem()
system.add_movie(m)
print(system.movies)
system.add_customer(c)
print(system.customers)


system.search_movie(c, "KINO")
print(c.movie_availibility)
system.rent_movie(m, c, 20)
c.view_rental_history()








